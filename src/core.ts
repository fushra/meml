// Note that this is loosely based on the crafting interpreters book, so it will
// have a similar code structure. We are not using java because java is pain
// Maybe one day I will rewrite this in rust or maybe even c to make it work natively
// but at the moment I don't really care

import { Web } from './targets/Web'
import { Parser } from './parser/Parser'
import { Scanner } from './scanner/Scanner'
import { Token } from './scanner/Token'
import { PageStmt } from './parser/Stmt'
import {
  CSSLoader,
  HTMLLoader,
  ILoader,
  JSLoader,
  MemlLoader,
  resetLinker,
} from './targets/loaders'
import { resetErrors } from './utils/Logging'

/**
 * The main class for handling compiling MEML files and general configuration.
 * Statics in this file are responsible for compiler configuration and an instance
 * of this class can be created to compile files.
 *
 * # Example usage
 *
 * ```ts
 * const path = require('path')
 * const fs = require('fs')
 *
 * const { MemlCore } = require('meml')
 *
 * MemlCore.sourcePath = path.join(__dirname, 'src')
 * MemlCore.distPath = path.join(__dirname, 'build')
 *
 * async function app() {
 *   const compiler = new MemlCore()
 *
 *   fs.writeFileSync('./dist/index.html', await compiler.fileToWeb('./src/index.meml'))
 * }
 *
 * app()
 * ```
 *
 * # Build process
 * The following steps are taken by the build process, with appropriate functions
 * available if you wish to break down the steps
 *
 * ```
 * Tokenizing -> Parsing -> Targeting
 * ```
 *
 * Note that whilst tokenizing and parsing generally remain constant, you can
 * create a custom target for your use case. There is no current documentation
 * for this, however it follows the structure layed out in
 * [crafting interpreters](https://craftinginterpreters.com/evaluating-expressions.html)
 * and you may use the source code in [the web target](https://github.com/fushra/meml/blob/main/src/targets/Web.ts)
 * as a starting point as long as your project is GPLv3 compatible.
 *
 * # Project management
 *
 * @TODO Should config be moved somewhere else?
 *
 * @TODO Should builds be moved into separate functions?
 */
export class MemlCore {
  /**
   * Keeps track of if an error has occurred. Can be reset between files using
   * `MemlCore.hadError()`
   */
  static hadError = false

  /**
   * A string containing the errors outputted to the console. Can be reset between
   * files using `MemlCore.hadError()`
   */
  static errors = ''

  /**
   * Instantiated loader objects for imported values
   */
  static globalLoaders: ILoader[] = [
    new MemlLoader(),
    new CSSLoader(),
    new HTMLLoader(),
    new JSLoader(),
  ]

  /**
   * Passed into each language loader (see `MemlCore.globalLoaders` and `ILoader`)
   * to determine if the output should be minified
   */
  static isProduction = false

  /**
   * If this is set, MEML will reference the files it imports rather than inlining
   * them. The following arguments **MUST** be set correctly for this to work:
   *  - `MemlCore.sourcePath`
   *  - `MemlCore.distPath`
   *
   * ## Example
   * **false** (default)
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <style>\* File contents here *\</style>
   * <!-- ... -->
   * ```
   *
   * **true**
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <link ... href="./something.css">
   * <!-- ... -->
   * ```
   */
  static shouldLink = false

  /**
   * The path where all source files are stored. Used when importing files, ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static sourcePath = process.cwd()

  /**
   * The path where files generated by loaded should be placed. Will be ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static distPath = process.cwd()

  // ------------------------------------------------------------
  // Interpreter stepping function

  /**
   * Converts the contents of the source string into an array of tokens ready
   * for parsing
   */
  tokenize(source: string, file = ''): Token[] {
    try {
      const scanner = new Scanner(source, file)
      return scanner.scanTokens()
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.tokenize`)
    }
  }

  /**
   * Converts the input tokens to an AST tree with a PageStmt as its root
   */
  parse(tokens: Token[], file = ''): PageStmt {
    try {
      const parser = new Parser(tokens, file)
      return parser.parse()
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.parse`)
    }
  }

  /**
   * Converts an AST tree to a html string
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  targetWeb(page: PageStmt, path = 'memory.meml'): Promise<string> {
    try {
      const target = new Web(path)
      return target.convert(page)
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.targetWeb`)
    }
  }

  tokenizeAndParse(source: string, file = ''): PageStmt {
    return this.parse(this.tokenize(source, file), file)
  }

  // ------------------------------------------------------------
  // Interpreter full functions

  /**
   * Converts a source MEML string to a string of html.
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  sourceToWeb(source: string, path = 'memory.meml'): Promise<string> {
    const tokens = this.tokenize(source, path)
    const parsed = this.parse(tokens, path)
    return this.targetWeb(parsed, path)
  }

  /**
   * Converts the contents of a file into a string of html.
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  async fileToWeb(path: string): Promise<string> {
    const { readFile } = await import('fs/promises')

    return this.sourceToWeb((await readFile(path)).toString(), path)
  }

  /**
   * Resets all errors generated by the compiler and linker cache. **Do not use**
   * between files, only between compilations. Use `MemlCore.resetErrors()`
   * between files.
   */
  static reset(): void {
    resetErrors()
    resetLinker()
  }

  /**
   * Register a new loader for linking and rendering
   */
  static registerLoader(Loader: ILoader): void {
    this.globalLoaders.push(Loader)
  }
}
