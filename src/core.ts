// Note that this is loosely based on the crafting interpreters book, so it will
// have a similar code structure. We are not using java because java is pain
// Maybe one day I will rewrite this in rust or maybe even c to make it work natively
// but at the moment I don't really care

import { readFile } from 'fs/promises'

import { grey, red, yellow } from 'kleur'

import { Web } from './targets/Web'
import { Parser } from './parser/Parser'
import { Scanner } from './scanner/Scanner'
import { Token } from './scanner/Token'
import { TokenType } from './scanner/TokenTypes'
import { PageStmt } from './parser/Stmt'
import {
  CSSLoader,
  HTMLLoader,
  ILoader,
  JSLoader,
  MemlLoader,
  resetLinker,
} from './targets/loaders'

/**
 * The main class for handling compiling MEML files and general configuration.
 * Statics in this file are responsible for compiler configuration and an instance
 * of this class can be created to compile files.
 *
 * # Example usage
 *
 * ```ts
 * const path = require('path')
 * const fs = require('fs')
 *
 * const { MemlCore } = require('meml')
 *
 * MemlCore.sourcePath = path.join(__dirname, 'src')
 * MemlCore.distPath = path.join(__dirname, 'build')
 *
 * async function app() {
 *   const compiler = new MemlCore()
 *
 *   fs.writeFileSync('./dist/index.html', await compiler.fileToWeb('./src/index.meml'))
 * }
 *
 * app()
 * ```
 *
 * # Build process
 * The following steps are taken by the build process, with appropriate functions
 * available if you wish to break down the steps
 *
 * ```
 * Tokenizing -> Parsing -> Targeting
 * ```
 *
 * Note that whilst tokenizing and parsing generally remain constant, you can
 * create a custom target for your use case. There is no current documentation
 * for this, however it follows the structure layed out in
 * [crafting interpreters](https://craftinginterpreters.com/evaluating-expressions.html)
 * and you may use the source code in [the web target](https://github.com/fushra/meml/blob/main/src/targets/Web.ts)
 * as a starting point as long as your project is GPLv3 compatible.
 *
 * # Project management
 *
 * @TODO Should config be moved somewhere else?
 *
 * @TODO Should builds be moved into separate functions?
 *
 * @TODO Move error reporting out of this class.
 */
export class MemlCore {
  /**
   * Keeps track of if an error has occurred. Can be reset between files using
   * `MemlCore.hadError()`
   */
  static hadError = false

  /**
   * A string containing the errors outputted to the console. Can be reset between
   * files using `MemlCore.hadError()`
   */
  static errors = ''

  /**
   * Instantiated loader objects for imported values
   */
  static globalLoaders: ILoader[] = [
    new MemlLoader(),
    new CSSLoader(),
    new HTMLLoader(),
    new JSLoader(),
  ]

  /**
   * Passed into each language loader (see `MemlCore.globalLoaders` and `ILoader`)
   * to determine if the output should be minified
   */
  static isProduction = false

  /**
   * If this is set, MEML will reference the files it imports rather than inlining
   * them. The following arguments **MUST** be set correctly for this to work:
   *  - `MemlCore.sourcePath`
   *  - `MemlCore.distPath`
   *
   * ## Example
   * **false** (default)
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <style>\* File contents here *\</style>
   * <!-- ... -->
   * ```
   *
   * **true**
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <link ... href="./something.css">
   * <!-- ... -->
   * ```
   */
  static shouldLink = false

  /**
   * The path where all source files are stored. Used when importing files, ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static sourcePath = process.cwd()

  /**
   * The path where files generated by loaded should be placed. Will be ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static distPath = process.cwd()

  // ------------------------------------------------------------
  // Interpreter stepping function

  /**
   * Converts the contents of the source string into an array of tokens ready
   * for parsing
   */
  tokenize(source: string, file = ''): Token[] {
    try {
      const scanner = new Scanner(source, file)
      return scanner.scanTokens()
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.tokenize`)
    }
  }

  /**
   * Converts the input tokens to an AST tree with a PageStmt as its root
   */
  parse(tokens: Token[], file = ''): PageStmt {
    try {
      const parser = new Parser(tokens, file)
      return parser.parse()
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.parse`)
    }
  }

  /**
   * Converts an AST tree to a html string
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  targetWeb(page: PageStmt, path = 'memory.meml'): Promise<string> {
    try {
      const target = new Web(path)
      return target.convert(page)
    } catch (e) {
      throw new Error(`${e.message}\n    MemlCore.targetWeb`)
    }
  }

  tokenizeAndParse(source: string, file = ''): PageStmt {
    return this.parse(this.tokenize(source, file), file)
  }

  // ------------------------------------------------------------
  // Interpreter full functions

  /**
   * Converts a source MEML string to a string of html.
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  sourceToWeb(source: string, path = 'memory.meml'): Promise<string> {
    const tokens = this.tokenize(source, path)
    const parsed = this.parse(tokens, path)
    return this.targetWeb(parsed, path)
  }

  /**
   * Converts the contents of a file into a string of html.
   *
   * May write files to disk depending on your settings for `shouldLink`
   */
  async fileToWeb(path: string): Promise<string> {
    return this.sourceToWeb((await readFile(path)).toString(), path)
  }

  /**
   * Resets all errors generated by the compiler and linker cache. **Do not use**
   * between files, only between compilations. Use `MemlCore.resetErrors()`
   * between files.
   */
  static reset(): void {
    this.resetErrors()
    resetLinker()
  }

  // ------------------------------------------------------------
  // Error functions

  /**
   * Resets `MemlCore.hadError` and `MemlCore.errors`
   */
  static resetErrors(): void {
    this.hadError = false
    this.errors = ''
  }

  /**
   * Internal error reporting function for reporting an error at a specific
   * token
   */
  static errorAtToken(token: Token, message: string, file = ''): void {
    if (token.type === TokenType.EOF) {
      this.report(token.line, ' at end', message, '', file)
    } else {
      this.report(
        token.line,
        ` at '${token.lexeme}'`,
        message,
        token.context,
        file
      )
    }
  }

  /**
   * Internal error reporting function
   */
  static error(line: number, message: string, file = ''): void {
    this.report(line, '', message, file)
  }

  /**
   * Internal error reporting function for reporting an linter warning at a specific
   * token
   */
  static linterAtToken(token: Token, message: string): void {
    this.warn(
      token.line,
      'Linter',
      ` at '${token.lexeme}'`,
      message,
      token.context
    )
  }

  /**
   * Internal warning function
   */
  static generalWarning(line: number, message: string): void {
    this.warn(line, 'General', '', message)
  }

  /**
   * Private error reporting function
   */
  private static report(
    line: number,
    where: string,
    message: string,
    context = '',
    file = ''
  ): void {
    console.error(
      red(
        `[line ${line}${
          file != '' ? ` in file ${file}` : ''
        }] Error${where}: ${message}\n${grey(this.formatContext(context))}`
      )
    )
    this.hadError = true
    this.errors += `[line ${line}${
      file != '' ? ` in file ${file}` : ''
    }] Error${where}: ${message}\n${this.formatContext(context)}\n`
  }

  /**
   * Private warning function
   */
  private static warn(
    line: number,
    type: 'Linter' | 'General',
    where: string,
    message: string,
    context = ''
  ): void {
    console.warn(
      yellow(
        `[line ${line}] ${type} warning${where}: ${message} \n${grey(
          this.formatContext(context)
        )}`
      )
    )

    this.errors += `[line ${line}] ${type} warning${where}: ${message} \n${this.formatContext(
      context
    )}\n`
  }

  /**
   * Internal error formatting function
   */
  static formatContext(context: string): string {
    return `    ┃${context.replace(/\n/g, '\n    ┃')}`
  }

  /**
   * Register a new loader for linking and rendering
   */
  static registerLoader(Loader: ILoader): void {
    this.globalLoaders.push(Loader)
  }
}
