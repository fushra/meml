// Note that this is loosely based on the crafting interpreters book, so it will
// have a similar code structure. We are not using java because java is pain
// Maybe one day I will rewrite this in rust or maybe even c to make it work natively
// but at the moment I don't really care

import { readFile } from 'fs/promises'

import { grey, red, yellow } from 'kleur'

import { Web } from './targets/Web'
import { Parser } from './parser/Parser'
import { Scanner } from './scanner/Scanner'
import { Token } from './scanner/Token'
import { TokenType } from './scanner/TokenTypes'
import { PageStmt } from './parser/Stmt'
import {
  CSSLoader,
  HTMLLoader,
  ILoader,
  JSLoader,
  MemlLoader,
  resetLinker,
} from './targets/loaders'

/**
 * The main class for handling compiling MEML files and general configuration.
 * Statics in this file are responsible for compiler configuration and an instance
 * of this class can be created to compile files.
 *
 * **Example usage**
 *
 * ```ts
 * const path = require('path')
 * const fs = require('fs')
 *
 * const { MemlCore } = require('meml')
 *
 * MemlCore.sourcePath = path.join(__dirname, 'src')
 * MemlCore.distPath = path.join(__dirname, 'build')
 *
 * async function app() {
 *   const compiler = new MemlCore()
 *
 *   fs.writeFileSync('./dist/index.html', await compiler.fileToWeb('./src/index.meml'))
 * }
 *
 * app()
 * ```
 *
 * TODO: Should config be moved somewhere else?
 * TODO: Should builds be moved into separate functions?
 * TODO: Move error reporting out of this class.
 */
export class MemlCore {
  /**
   * Keeps track of if an error has occurred. Can be reset between files using
   * `MemlCore.hadError()`
   */
  static hadError = false

  /**
   * A string containing the errors outputted to the console. Can be reset between
   * files using `MemlCore.hadError()`
   */
  static errors = ''

  /**
   * Instantiated loader objects for imported values
   */
  static globalLoaders: ILoader[] = [
    new MemlLoader(),
    new CSSLoader(),
    new HTMLLoader(),
    new JSLoader(),
  ]

  /**
   * Passed into each language loader (see `MemlCore.globalLoaders` and `ILoader`)
   * to determine if the output should be minified
   */
  static isProduction = false

  /**
   * If this is set, MEML will reference the files it imports rather than inlining
   * them. The following arguments **MUST** be set correctly for this to work:
   *  - `MemlCore.sourcePath`
   *  - `MemlCore.distPath`
   *
   * ## Example
   * **false** (default)
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <style>\* File contents here *\</style>
   * <!-- ... -->
   * ```
   *
   * **true**
   * ```meml
   * (import './something.css')
   * ```
   * Out:
   * ```html
   * <!-- ... -->
   * <link ... href="./something.css">
   * <!-- ... -->
   * ```
   */
  static shouldLink = false

  /**
   * The path where all source files are stored. Used when importing files, ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static sourcePath = process.cwd()

  /**
   * The path where files generated by loaded should be placed. Will be ignored
   * if `MemlCore.shouldLink` is set to `false`.
   */
  static distPath = process.cwd()

  // ------------------------------------------------------------
  // Interpreter stepping function

  tokenize(source: string, file = ''): Token[] {
    const scanner = new Scanner(source, file)
    return scanner.scanTokens()
  }

  parse(tokens: Token[], file = ''): PageStmt {
    const parser = new Parser(tokens, file)
    return parser.parse()
  }

  targetWeb(page: PageStmt, path = 'memory.meml'): Promise<string> {
    const target = new Web(path)
    return target.convert(page)
  }

  tokenizeAndParse(source: string, file = ''): PageStmt {
    return this.parse(this.tokenize(source, file), file)
  }

  // ------------------------------------------------------------
  // Interpreter full functions

  sourceToWeb(source: string, path = 'memory.meml'): Promise<string> {
    const tokens = this.tokenize(source, path)
    const parsed = this.parse(tokens, path)
    return this.targetWeb(parsed, path)
  }

  async fileToWeb(path: string): Promise<string> {
    return this.sourceToWeb((await readFile(path)).toString(), path)
  }

  static reset(): void {
    this.resetErrors()
    resetLinker()
  }

  // ------------------------------------------------------------
  // Error functions

  static resetErrors(): void {
    this.hadError = false
    this.errors = ''
  }

  static errorAtToken(token: Token, message: string, file = ''): void {
    if (token.type === TokenType.EOF) {
      this.report(token.line, ' at end', message, '', file)
    } else {
      this.report(
        token.line,
        ` at '${token.lexeme}'`,
        message,
        token.context,
        file
      )
    }
  }

  static error(line: number, message: string, file = ''): void {
    this.report(line, '', message, file)
  }

  static linterAtToken(token: Token, message: string): void {
    this.warn(
      token.line,
      'Linter',
      ` at '${token.lexeme}'`,
      message,
      token.context
    )
  }

  static generalWarning(line: number, message: string): void {
    this.warn(line, 'General', '', message)
  }

  private static report(
    line: number,
    where: string,
    message: string,
    context = '',
    file = ''
  ): void {
    console.error(
      red(
        `[line ${line}${
          file != '' ? ` in file ${file}` : ''
        }] Error${where}: ${message}\n${grey(this.formatContext(context))}`
      )
    )
    this.hadError = true
    this.errors += `[line ${line}${
      file != '' ? ` in file ${file}` : ''
    }] Error${where}: ${message}\n${this.formatContext(context)}\n`
  }

  private static warn(
    line: number,
    type: 'Linter' | 'General',
    where: string,
    message: string,
    context = ''
  ): void {
    console.warn(
      yellow(
        `[line ${line}] ${type} warning${where}: ${message} \n${grey(
          this.formatContext(context)
        )}`
      )
    )

    this.errors += `[line ${line}] ${type} warning${where}: ${message} \n${this.formatContext(
      context
    )}\n`
  }

  static formatContext(context: string): string {
    return `    ┃${context.replace(/\n/g, '\n    ┃')}`
  }

  static registerLoader(Loader: ILoader): void {
    this.globalLoaders.push(Loader)
  }
}
